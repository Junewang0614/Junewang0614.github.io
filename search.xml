<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记-11</title>
      <link href="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11/"/>
      <url>/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11/</url>
      
        <content type="html"><![CDATA[<h2 id="Structured-support-vector-machine"><a href="#Structured-support-vector-machine" class="headerlink" title="Structured support vector machine"></a>Structured support vector machine</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-10</title>
      <link href="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/"/>
      <url>/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/</url>
      
        <content type="html"><![CDATA[<h2 id="Structured-Learning-结构化学习"><a href="#Structured-Learning-结构化学习" class="headerlink" title="Structured Learning 结构化学习"></a>Structured Learning 结构化学习</h2><p>对应视频<a href="https://www.bilibili.com/video/BV13x411v7US" target="_blank" rel="noopener">BV13x411v7US</a> P32</p><a id="more"></a><p>1、应用举例</p><ul><li>语音辨识</li><li>翻译</li><li>句法分析 syntactic parsing</li><li>对象检测 object detection<br>等等<br><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/01.png" alt="01"></li></ul><h3 id="Unified-Framework-统一框架"><a href="#Unified-Framework-统一框架" class="headerlink" title="Unified Framework 统一框架"></a>Unified Framework 统一框架</h3><p><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/02.png" alt="02"></p><p>主要分为training训练和inference推断两步：</p><ul><li>training部分目的是找到F(X,Y)，训练数据x与y都是输入值，F的输出值是一个评判值，当x与y越匹配的时候，F得到的输出值越高，F是评估x与y匹配的一个函数。</li><li>inference 推断：将未知的X值输入，然后穷举所有可能的Y，将X与Y带入训练好的F函数中，使得F函数值最高的Y，即我们要找的输出。</li></ul><p>以对象检测为例<br>输入：一张图像<br>输出：想要寻找的对象所在的位置</p><h4 id="Training-训练部分"><a href="#Training-训练部分" class="headerlink" title="Training 训练部分"></a>Training 训练部分</h4><p><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/03.png" alt="03"><br>如上图，将图像X与框框Y随机匹配，当Y框对了对象的时候，F的值最高，当Y框了部分对象的时候，F的值偏低，当Y完全没有框对对象时，F的值最低。我们要训练的就是这样的一个F函数。</p><h4 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h4><p><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/04.png" alt="04"><br>输入没有接触过的图像x，穷举所有的框框Y，依次与X一起放入训练好的F函数，进行匹配，当F越高，说明Y框框正确的可能性越大（或者框出的部分中，正确的部分占比越大），取使得F最大的Y，就是我们需要的输出。</p><h3 id="统一框架中的三大问题以及解决方法"><a href="#统一框架中的三大问题以及解决方法" class="headerlink" title="统一框架中的三大问题以及解决方法"></a>统一框架中的三大问题以及解决方法</h3><p><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/05.png" alt="05"></p><p>以结构化线性模型为例</p><h4 id="Problem-1：F函数是一个什么样的函数"><a href="#Problem-1：F函数是一个什么样的函数" class="headerlink" title="Problem-1：F函数是一个什么样的函数"></a>Problem-1：F函数是一个什么样的函数</h4><p><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/06.png" alt="06"></p><h4 id="Problem-2：怎么做，才能穷举所有的Y，得到使得F函数最大值的Y，即如何解决最大化问题"><a href="#Problem-2：怎么做，才能穷举所有的Y，得到使得F函数最大值的Y，即如何解决最大化问题" class="headerlink" title="Problem-2：怎么做，才能穷举所有的Y，得到使得F函数最大值的Y，即如何解决最大化问题"></a>Problem-2：怎么做，才能穷举所有的Y，得到使得F函数最大值的Y，即如何解决最大化问题</h4><p><strong>假设问题已经被解决了</strong></p><h4 id="Problem-3：如何通过训练找到F函数"><a href="#Problem-3：如何通过训练找到F函数" class="headerlink" title="Problem-3：如何通过训练找到F函数"></a>Problem-3：如何通过训练找到F函数</h4><p>由第一个问题可得，解决这个问题的实质是，找到满足什么样的条件的W向量。满足的条件如图的黄色部分所示：</p><p><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/07.png" alt="07"></p><p>即：w与正确的(x,y)对的特征做内积的值，都会大于任意的W与其他的(x,y)对做内积的值。</p><p>举例说明：<br><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/08.png" alt="08"><br>其中红色的点是正确的点（training data),蓝色的点是任意点。<br>根据内积的几何意义，也就是将每一个(x,y)对，投影在W向量方向上，<strong>要满足所有红色的同类型的点，在W向量方向上的值是最大的。</strong><br>需要根据training data训练出这样的W向量</p><p><strong>解决方案演算法</strong><br><img src="/2020/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10/09.png" alt="09"></p><p>主要步骤：</p><ul><li>初始化W为0</li><li>对于每一对training data,穷举所有的Y，然后将对应的(x,y)特征与目前的W做内积，选出使得这个内积最大的y’。（这个其实是第二个问题，现在我们假设了第二个问题已经被解决了，也就是我们可以计算出最大值，以及找到对应的y）</li><li>如果y’ != 正确的y，按照图片上的式子更新W的值，再进入训话计算。</li><li>直到对于训练集中所有的(x，y)对，使得W与特征的内积最大的就是正确的y的时候，W不再更新，跳出循环，训练完成。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-09</title>
      <link href="/2020/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09/"/>
      <url>/2020/09/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09/</url>
      
        <content type="html"><![CDATA[<h2 id="Unsupervised-Learning-无监督学习"><a href="#Unsupervised-Learning-无监督学习" class="headerlink" title="Unsupervised Learning 无监督学习"></a>Unsupervised Learning 无监督学习</h2><p>对应视频<a href="https://www.bilibili.com/video/BV13x411v7US" target="_blank" rel="noopener">BV13x411v7US</a> P24</p><ul><li>化繁为简<br>  输入比较复杂的input，得到比较简单的output<br>  拥有的训练data，只有input，不知道output</li><li>无中生有<br>  训练某种function，训练集里只有function的output</li></ul><h3 id="Clustering-聚类"><a href="#Clustering-聚类" class="headerlink" title="Clustering  聚类"></a>Clustering  聚类</h3><p>化繁为简的好方法</p><ul><li><p>K-means（K均值）：将X集合里的元素聚类为K个类别。</p></li><li><p>HAC(hierarchical Agglomerative Clustering)凝聚层次聚类：<br>利用树的结构表示Data<br>在树的不同层次划分，可以得到不同数量的class。</p></li></ul><h3 id="Dimension-Reduction-降维"><a href="#Dimension-Reduction-降维" class="headerlink" title="Dimension Reduction   降维"></a>Dimension Reduction   降维</h3><p>从比较高维的空间变为比较低维的空间。<br>实质是输入一个x，经过某一function，得到输出z，z的维度小于x的维度。</p><p>方法：</p><ul><li>Feature selection 特征选择</li><li>Principle component analysis(PCA) 主成分分析</li></ul><p>（未完待续）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-08</title>
      <link href="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/"/>
      <url>/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/</url>
      
        <content type="html"><![CDATA[<h2 id="Semi-supervised-Learning-半监督学习"><a href="#Semi-supervised-Learning-半监督学习" class="headerlink" title="Semi-supervised Learning 半监督学习"></a>Semi-supervised Learning 半监督学习</h2><p>对应视频<a href="https://www.bilibili.com/video/BV13x411v7US" target="_blank" rel="noopener">BV13x411v7US</a> P23</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>半监督学习的特点是，训练数据中存在一部分没有标记的数据，且数据量一般比标记后的数据要大。</li><li>为什么使用半监督学习？因为我们更多的数据是没有标记的，如果能有效地利用这些未标记数据可以将模型训练的更好，但是这方面，精确的“假设”起很重要的作用。</li></ul><a id="more"></a><h3 id="generative-model-生成模型"><a href="#generative-model-生成模型" class="headerlink" title="generative model 生成模型"></a>generative model 生成模型</h3><p>1、初始化模型参数后，计算每一个没有标记数据的后验概率，看看是输入哪一类别。</p><p>2、利用已经得到的数据，再次更新模型的参数（协方差、均值等）</p><p>3、反复第一步第二步，理论上模型最后会收敛。</p><h3 id="self-training"><a href="#self-training" class="headerlink" title="self-training"></a>self-training</h3><h3 id="Entropy-based-Regularization"><a href="#Entropy-based-Regularization" class="headerlink" title="Entropy-based Regularization"></a>Entropy-based Regularization</h3><p>1、我们通过标记数据的得到的模型，用来计算未标记的数据，这时候得到的对应的y是一些分布（distribution），这个分布越偏向某一类是越好的分布。判断分布的好坏可以利用信息熵来计算。信息熵为0是好的，信息熵很大的是不好的。</p><p><img src="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/01.png" alt="01"></p><p>2、根据这个假设可以重新设置loss函数。</p><p>全新的loss函数由两部分组成：第一部分对应的是labelled data，计算模型中的y值和实际的y值的距离；第二部分对应的是unlabeled data，计算信息熵让其最小化。</p><p><img src="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/02.png" alt="02"></p><h3 id="Smoothness-Assumption-平滑的假设"><a href="#Smoothness-Assumption-平滑的假设" class="headerlink" title="Smoothness Assumption(平滑的假设)"></a>Smoothness Assumption(平滑的假设)</h3><p><strong>假设：对于相似的X，Y值假设是一样的</strong><br>详细：1、x是不平均的，在某些地方集中，在某些地方分散。<br>2、当x1,x2在高密度的地方是接近的，y1与y2假设是一样的。</p><p><img src="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/03.png" alt="03"></p><p>x1,x2更偏向于有相同的y。</p><h4 id="Graph-based-Approach"><a href="#Graph-based-Approach" class="headerlink" title="Graph-based Approach"></a>Graph-based Approach</h4><p>通过图的连通性，反映两个点之间的相似性。</p><ul><li>将数据用图的形式表示出来</li><li>labelled data会影响自身连接的邻居值。</li><li>被影响的数据点，也具有影响性，可以影响其他与其相连的点，即使这个点没有和任何的labelled data相连。</li></ul><p><img src="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/04.png" alt="04"></p><p>定量表示smoothness<br><img src="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/05.png" alt="05"><br><strong>s的值越小，表示越光滑</strong></p><p>根据该假设又可以重新定义Loss函数<br><img src="/2020/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08/06.png" alt="06"></p><h3 id="Better-Representation"><a href="#Better-Representation" class="headerlink" title="Better Representation"></a>Better Representation</h3><ul><li>化繁为简<br>比较复杂的事物是由比较简单的事物操控，透过现象看到本质以后能进行更好的训练。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-07</title>
      <link href="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/"/>
      <url>/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/</url>
      
        <content type="html"><![CDATA[<h2 id="Recurrent-Neural-Network-RNN"><a href="#Recurrent-Neural-Network-RNN" class="headerlink" title="Recurrent Neural Network(RNN)"></a>Recurrent Neural Network(RNN)</h2><p>对应视频：p20-p21</p><a id="more"></a><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><h4 id="Elman-Network"><a href="#Elman-Network" class="headerlink" title="Elman Network"></a>Elman Network</h4><p><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/01.png" alt="01"></p><ul><li>橙、绿、黄构成一个前馈神经网络，蓝色保存了中间层的输出内容。</li><li>三个前馈神经网络是同一个神经网络，使用时间不同，输入的蓝色部分的内容也因此不同。蓝色的存储元件是循环神经网络的重点。</li></ul><p>构成深度神经网络也可以，每一层的输出内容都会被保存下来。<br><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/02.png" alt="02"></p><ul><li>其中蓝色箭头表示每一次存储下来的内容，第一次是需要为其赋初始值。</li><li><strong>Elman Network的特点是，保存的是每一个隐藏层的输出值</strong></li></ul><h4 id="Jordan-Network"><a href="#Jordan-Network" class="headerlink" title="Jordan Network"></a>Jordan Network</h4><p><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/03.png" alt="03"></p><ul><li><strong>jordan network的特点是，把每一次的真实输出值保存下来，作为下一次的输入部分</strong></li></ul><h3 id="Long-Short-term-Memory（LSTM）"><a href="#Long-Short-term-Memory（LSTM）" class="headerlink" title="Long Short-term Memory（LSTM）"></a>Long Short-term Memory（LSTM）</h3><h4 id="1、构成"><a href="#1、构成" class="headerlink" title="1、构成"></a>1、构成</h4><ul><li>Memory Cell：存储内容</li><li>Input Gate：某一内容能否保留在Memory Cell中，需要操纵信号</li><li>Output Gate: 外界可不可以得到当前保存的内容，需要操纵讯号</li><li>Forget Gate：将memory Cell中的内容忘掉，需要操纵讯号</li></ul><p>其中后面三个Gate什么时候打开什么时候关闭都是由机器自主学习决定。<br><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/04.png" alt="04"><br>蓝色箭头是四个输入：input gate信号、input的内容，output gate信号，forget gate信号<br>红色箭头是一个输出：output输出。</p><h4 id="2、工作流程"><a href="#2、工作流程" class="headerlink" title="2、工作流程"></a>2、工作流程</h4><p><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/05.png" alt="05"></p><ul><li>原来的cell中保存的内容为C</li><li>其中所有为f的函数，都是sigmoid函数，因为可以将输入的值变换后控制在0-1之间，0代表门关闭，1代表门打开。</li><li>g，h函数则是对输入的内容进行一定的变换。</li><li>最终的输出为a</li></ul><p><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/06.png" alt="06"></p><ul><li><p>第一步输入z，经过g函数得到g(z)，这是想要保存的内容。经过f函数得到f(zi)，这是判断能否输入的标志，如果为0则不能输入——相当于输入的值为0.</p></li><li><p>第二步经过f函数得到f(zf)，这是forget gate的标志。不同的是，如果值为0，代表cell中的内容被清洗了，而如果值为1，cell中的内容依旧保留着。</p></li><li><p>第三步，经过输入后，重新保存在cell中的c’公式为：</p><p>c’ = g(z)f(zi)(新输入的部分) + cf(zf)(之前保存的部分)</p></li><li><p>第四步，保存在cell中的内容经过h函数变换为h(c’)，这是可能将会输出的内容，经过f函数得到f(zo)，如果为0，则数据不会输出——相当于输出值为0。</p><p>最后实际输出值a = f(zo)h(c’)</p></li><li><p>图上所有f的部分，代表的都是一些讯号。</p></li></ul><h4 id="3、网络构成"><a href="#3、网络构成" class="headerlink" title="3、网络构成"></a>3、网络构成</h4><ol><li><p>理论基础流程</p><p> <img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/07.png" alt></p></li><li><p>实际</p><p><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/08.png" alt></p></li></ol><h3 id="RNN学习问题"><a href="#RNN学习问题" class="headerlink" title="RNN学习问题"></a>RNN学习问题</h3><h4 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h4><h4 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h4><p>通过LSTM可以解决</p><p>原理解释：LSTM中memory的更新，是旧值+新值，在forget gate不工作的时候，旧值不会被刷新，旧值的影响始终是存在的。</p><h3 id="RNN应用"><a href="#RNN应用" class="headerlink" title="RNN应用"></a>RNN应用</h3><ol><li>输入序列，得到一个结果（many to one）</li></ol><ul><li>sentiment analysis情感分析</li></ul><ol start="2"><li>many to many（output &lt; input)</li></ol><ul><li>语音辨识 speech recognition</li><li>CTC：Connectionist Temporal Classification,核心是加一个NULL的标识输出，解决叠字问题。</li></ul><ol start="3"><li>sequence to sequence（no limitation）<ul><li>机器翻译</li><li>Syntactic parsing</li><li>语音信号可以转换为向量</li><li>聊天机器人</li></ul></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Attention-based-Model"><a href="#Attention-based-Model" class="headerlink" title="Attention-based Model"></a>Attention-based Model</h4><p><img src="/2020/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07/09.png" alt="09"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythorch</title>
      <link href="/2020/08/03/pythorch/"/>
      <url>/2020/08/03/pythorch/</url>
      
        <content type="html"><![CDATA[<h2 id="PyTorch-Introduction"><a href="#PyTorch-Introduction" class="headerlink" title="PyTorch Introduction"></a>PyTorch Introduction</h2><h3 id="tensor张量"><a href="#tensor张量" class="headerlink" title="tensor张量"></a>tensor张量</h3><p>1、与numpy的相互转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tensor-&gt;numpy ：</span></span><br><span class="line">y_numpy = torch.numpy(x_tensor)</span><br><span class="line"><span class="comment">#numpy-&gt;tensor ：</span></span><br><span class="line">y_torch = torch.from_numpy(x_numpy)</span><br></pre></td></tr></table></figure><p>2、tensor可以转变矩阵形状，只要总共的元素数不变就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tensor.view</span></span><br><span class="line">x = torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">y = x.view(<span class="number">15</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">5</span>)  <span class="comment"># -1所指的维度可以根据其他维度的值推出来</span></span><br><span class="line"><span class="comment">#只有一个维度可以赋值-1！</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><p>3、</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS224n-01</title>
      <link href="/2020/08/03/CS224n-01/"/>
      <url>/2020/08/03/CS224n-01/</url>
      
        <content type="html"><![CDATA[<h2 id="词向量表示"><a href="#词向量表示" class="headerlink" title="词向量表示"></a>词向量表示</h2><p><a href="https://www.bilibili.com/video/BV1pt411h7aT?p=2" target="_blank" rel="noopener">bilibili</a> —p2</p><p>nltk</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《神经网络与深度学习》第一章 阅读笔记</title>
      <link href="/2020/08/02/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2020/08/02/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-机器学习概述"><a href="#第二章-机器学习概述" class="headerlink" title="第二章 机器学习概述"></a>第二章 机器学习概述</h2><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、特征 or 属性：x，特征向量</p><p>2、标签 y</p><p>3、数据集、训练集、测试集</p><p>4、函数 f</p><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p><img src="/2020/08/02/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%89%E8%A6%81%E7%B4%A0.png" alt="01"></p><h3 id="机器学习算法类型"><a href="#机器学习算法类型" class="headerlink" title="机器学习算法类型"></a>机器学习算法类型</h3><p><img src="/2020/08/02/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B.png" alt="02"></p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>1、准确率，错误率   准确率+错误率 = 1</p><p>2、精确率和召回率（对每个类进行性能估计）</p><p>模型在测试集的结果分为以下四类：</p><ul><li>真正例：TP，实际为c，预测为c</li><li>假负例：FN，实际为c，预测为其他</li><li>假正例：FP，实际为其他，预测为c</li><li>真负例：TN，实际为其他，预测为其他</li></ul><p>精确率：所有预测为类别c(P)中正确的比例：TP<sub>c</sub>/(TP<sub>c</sub>+FP<sub>c</sub>)</p><p>召回率：所有真实类别为c中正确的比例：TP<sub>c</sub>/(TP<sub>c</sub> + FN<sub>c</sub>)</p><p>3、F值：综合指标，召回率和精确率的调和平均</p><p><img src="/2020/08/02/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/03.png" alt="03"></p><p>4、宏平均：每一类性能指标的算术平均、微平均：每一个样本的性能指标的算数平均</p><p>5、交叉验证：原始数据集均分为K组不重复子集，每次选择k-1作为训练集，剩下一组作为验证集。从而进行K次训练，得到K组模型，将k个模型在各自验证集上的错误率的平均作为分类器的评价。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-06</title>
      <link href="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/"/>
      <url>/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/</url>
      
        <content type="html"><![CDATA[<h2 id="Convolutional-Neural-Network-CNN"><a href="#Convolutional-Neural-Network-CNN" class="headerlink" title="Convolutional Neural Network(CNN)"></a>Convolutional Neural Network(CNN)</h2><p>简化整体网络结构，选择较少的参数（相较于全连接前馈网络）。</p><p><a href="https://www.bilibili.com/video/BV1sE411K7Lw?p=15" target="_blank" rel="noopener">bilibili</a> P14</p><a id="more"></a><h3 id="影像处理为例"><a href="#影像处理为例" class="headerlink" title="影像处理为例"></a>影像处理为例</h3><p>Q1：为什么可以将全连接网络里面的一些参数去掉，简化网络？</p><p>A：1、每一个neural都类似于一个分类器，用以判断某些特征，特定特征的判断需要的是相对应的输入，部分的输入内容就可以决定相关特征而不需要利用所有输入进行判断。<br>2、相同的特征判断可能存在于输入的不同位置（比如两张图片中同是鸟嘴但位置不同），但此时使用相同的的neural就好，而不需要两个neural，可以让两个neural相互share参数，共用同一组参数工作。<br>3、subsampling（比如缩小）对图像的判断可能没有影响，可以通过二次抽样来减少参数的使用。</p><h3 id="CNN全过程"><a href="#CNN全过程" class="headerlink" title="CNN全过程"></a>CNN全过程</h3><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/07.png" alt="07"></p><h3 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h3><p>Q1：Convolution做了什么？</p><p>A：（以影像处理为例），convolution做了第1、2部分。通过卷积的方式，将不同位置的相同的特征，借助filter过滤器，提取出不同的特征图谱。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/01.png" alt="01"></p><p>eg：过滤器在右上角，是3<em>3的矩阵。过滤器每次取图片的一部分（大小相同的一部分）做内积，得到一个结果，然后移动固定的步数（这里是1），继续做内积，最后得到了新的4\</em>4的矩阵。多个filter做相同的事情，得到很多矩阵，合在一起成为了特征图谱。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/02.png" alt="02"></p><p>Q2：convolution和全连接网络的关系，以及why？</p><p>A：convolution的实质，就是全连接网络某一层中，去掉一些weight的结果。输出的特征矩阵的每一个值，相当于网络中某一个神经元的输出值。全连接网络中每一个神经元得到的输入是全部的输入，convolution中输入只是与过滤器做内积的那部分选中的输入。而过滤器矩阵的值其实就是weight值，是机器可以自己学习出来的内容。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/03.png" alt="03"></p><ul><li>部分的输入带来了较少的参数值，需要自主学习的参数的数量减少了。</li><li>16个神经元，只是每个神经元的输入对应input的不同的部分，使用的过滤器相同–&gt;每次计算所利用的权值相同–&gt;shared weights–&gt;又可以减少参数的数量。</li></ul><h3 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max Pooling"></a>Max Pooling</h3><p>convolution的输出矩阵，将矩阵按照一定规则划分，并按照一定规则在每个划分区域进行计算或者选择，使每个区域保留一个数值，生成新的矩阵。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/04.png" alt="04"></p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/05.png" alt="05"></p><h4 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h4><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/06.png" alt="06"></p><p>经过一次convolution+max pooling，原本是6*6的图片特征变成了2*2的特征图谱。新的特征图谱可以作为input参与下一次的convolution+max pooling，这一套可以重复很多次，每一次都会缩小矩阵大小。</p><p><strong>其他</strong></p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/08.png" alt="08"></p><p>剩下的两步：flatten相当于是把立体的特征图谱矩阵拉成多维向量，作为全新的input输入到全连接网络，全连接网络进行计算，output，结束。</p><h3 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h3><p>（以图像识别为例）</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>每一个filter的作用是什么？</p><p>方法：在model已经训练好，参数全部固定的情况下，不断调整输入的x的值（输入的图片），要调整到被观测的filter的活跃度最高，其中活跃度的定义为通过该过滤器输出的矩阵的每一个值的总和。</p><p>结果发现每一个filter的作用是检测某种类型的线条走向，例如纵线条、横线条、不同方向的斜线条等。</p><h4 id="neural"><a href="#neural" class="headerlink" title="neural"></a>neural</h4><p>最后的全连接神经网络中每一个neural的作用是什么？</p><p>方法：（类似），调整输入x，最大化当前neural的输出值。</p><p>结果：侦测的是比较完整的一个图像，与filter不同的是，filter的输入只是图像中很小的一部分内容，侦测的也只是那一部分的特征，而全连接神经网络每一个neural都是输入所有的input，所以反应的是要侦测的整个图像的特征。</p><h4 id="output-layer"><a href="#output-layer" class="headerlink" title="output layer"></a>output layer</h4><p>最后的输出层的作用是什么？</p><p>方法：方法同理</p><p>结果猜想应该是数字的样子。但是最后的结果并不是这样，每一种输出都是相似的混乱的图片。说明机器最终学习到的和人类还是很不一样的内容，虽然都能对图像作出判断，但是其中的原理有很大区别。</p><p><strong>调整</strong></p><p>方法：使得输出y值最大的同时，也要让输入的x最小（黑白图中，x越大表示笔画部分越多，空白部分越少）。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-06/09.png" alt="09"></p><ul><li><p>好玩的其他研究应用：deep dream，deep style</p></li><li><p>CNN在下围棋上表现比普通的全连接网络表现更好。（why？）</p><p>围棋图谱有和图像识别相类似的地方，也就是适合CNN处理的地方</p><ol><li>图谱中也有很多特征（基本的pattern），远小于整个图谱的大小。</li><li>很多相同的特征（pattern），可以出现在不同的位置，代表同样的意义。</li></ol></li><li><p>Alpha Go的CNN结构的特别之处：没有使用Max Pooling，因为Max pooling 不需要被使用在围棋处理架构中。（第三个特征不符）</p></li><li><p>Speech应用，将音频图片输入到CNN，同样是对图片的处理。</p></li><li><p>text，文字处理应用，同样类似于处理图像</p></li></ul><p>感觉CNN的实质还是针对于图像处理的那三个特点，这样的表现有很好的效果。其他方面的应用也是有这方面的原理在，是三个特点的变形使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-05</title>
      <link href="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/"/>
      <url>/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/</url>
      
        <content type="html"><![CDATA[<h2 id="Backpropagation——反向传播"><a href="#Backpropagation——反向传播" class="headerlink" title="Backpropagation——反向传播"></a>Backpropagation——反向传播</h2><p>是有效计算gradient的向量的方法，因为随着网络的层数的增加，参数越来越多，向量越来越长，计算越来越复杂，使用反向传播比较高效。</p><a id="more"></a><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="chain-rule-链式法则"><a href="#chain-rule-链式法则" class="headerlink" title="chain rule 链式法则"></a>chain rule 链式法则</h4><p>用于多变量求导</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/01.png" alt="01"></p><h4 id="σ-z-函数"><a href="#σ-z-函数" class="headerlink" title="σ(z)函数"></a>σ(z)函数</h4><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/05.png" alt="05"></p><h3 id="backpopagation过程"><a href="#backpopagation过程" class="headerlink" title="backpopagation过程"></a>backpopagation过程</h3><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/02.png" alt="02"></p><p>梯度下降的方式是用于求得Loss函数的最小值，loss函数是一个求和函数，取决于每一个l的值，所以重点在于计算w参数对C的微分。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/03.png" alt="03"></p><p>(其中C就是上图的小l)</p><p>求w对C的微分，可以通过链式法则分解，引入中间变量z。<br>求w对z的微分是forward pass，有图可得，w1对z的偏微分就是x1,可以以此类推，w<sub>n</sub>对z的偏微分，就是w<sub>n</sub>前面的input值。<br>求z对C的微分是backward pass</p><h4 id="Forward-pass"><a href="#Forward-pass" class="headerlink" title="Forward pass"></a>Forward pass</h4><p>正如前面所述，w<sub>n</sub>对z的偏微分，就是w<sub>n</sub>前面的input值。一定是当层的、最接近的input的值，可以是来自外部输出，也可以是来自前一层网络。<br><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/04.png" alt="04"></p><h4 id="Backward-pass"><a href="#Backward-pass" class="headerlink" title="Backward pass"></a>Backward pass</h4><p>考虑的是下一步发生了什么事情。</p><p>引入中间变量a，使得a = σ(z)</p><p>可以通过链式法则展开，得到z对C的偏微分。<br><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/07.png" alt="06"><br>其中可以看到关系可以普遍简化定义为:a会影响z’，z’’(可能还有别的z)，z’,z’’会影响c，从而有a影响了c，通过链式法则可以表示出c对a的偏微分。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/06.png" alt="05"></p><p>第一项a对z’等的偏微分都很好算，a是作为input的层，通过forward pass可以知道，对应的是w1,w2……w<sub>n</sub>,后面那一项我们无从下手。</p><p><strong>假定我们已经知道后面那一项的值，则整个式子可以进行一定的整理</strong></p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/08.png" alt="08"></p><p><strong>如何计算未知的两项？ – 分类讨论</strong></p><ul><li><p>case 1:已经到达了output layer</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/09.png" alt="09"></p></li><li><p>case 2 Not output layer</p><p><strong>通过递归的方式计算，直到打倒了output 层，然后可以回溯到前面层</strong></p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/10.png" alt="10"></p></li></ul><p><strong>实际计算方式</strong></p><p>computer z对c的偏微分 from the <strong>output layer</strong>,从输出层向后计算，计算有效率。</p><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/11.png" alt="11"></p><p>实际是，建立一个<strong>反向的神经网络</strong>，来计算整个的偏微分。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>先计算ForWard pass</li><li>再通过逆向网络计算 Backward pass</li><li>两者相乘，最终得到了w对C的偏微分</li></ul><p><img src="/2020/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-05/12.png" alt="12"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《神经网络与深度学习》第一章 阅读笔记</title>
      <link href="/2020/07/26/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2020/07/26/NNDL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h2><p>基本概念一览</p><a id="more"></a><h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><p>人工智能就是让机器人具有人类的智能。</p><p>就是要让机器的行为看起来就像是人所表现出的智能的行为一样。</p><p>因为“智能”较难定义，判断机器是否智能的方式则采用“图灵测试”。</p><p>人工智能主要领域划分：</p><ul><li>感知（语音信息处理、计算机视觉等）</li><li>学习（监督学习、半监督、无监督学习等）</li><li>认知（知识表示、自然语言理解、推理等）</li></ul><p>人工智能发展历程：<br>推理期（规律较简单） — 知识期（知识库、专家系统）— 学习期（计算机从数据中自主学习）</p><p>人工智能流派（主要）：符号主义与连接主义。</p><h4 id="机器学习（Machine-Learning"><a href="#机器学习（Machine-Learning" class="headerlink" title="机器学习（Machine Learning)"></a>机器学习（Machine Learning)</h4><p>机器学习是指从有限的观测数据中学习出具有一般性的规律，并利用这些规律对未知的数据进行预测的方法。</p><p>机器学习模型一般包括以下步骤：<br><strong>数据预处理 – 特征提取 – 特征转换 – 预测</strong><br><strong>其中预测是机器学习的核心部分，机器需要自主学习到一个函数（模型），来进行未知数据的预测</strong></p><p>传统的机器学习，实际操作过程中，数据预处理、特征提取、特征转换反而需要人类干预，好的特征影响着最终模型，所以有时机器学习的主要工作量在特征问题上。这其实是一种“浅层学习”</p><h4 id="表示学习-Representation-Learning"><a href="#表示学习-Representation-Learning" class="headerlink" title="表示学习(Representation Learning)"></a>表示学习(Representation Learning)</h4><p>表示，或称之为特征<br>表示学习指可以自动的学习出有效的特征，并提高最终机器学习模型的性能的学习。</p><p>表示学习两个核心问题：什么是好的表示？ 如何学习到好的表示？</p><p>好的表示的优点：</p><ul><li>很强的表示能力</li><li>使后续的学习任务变得简单</li><li>具有一般性，可以比较容易迁移到其他任务上</li></ul><h5 id="常用表示"><a href="#常用表示" class="headerlink" title="常用表示"></a>常用表示</h5><ol><li><p>局部表示</p><p>用一个很长的向量表示特征，有则为1，无则为0</p><p>优点：很好的解释性；稀疏的二值向量，计算效率很高</p><p>不足：向量的维数很高，不易扩展（扩展就要增维）；不同特征之间的相关性都相同，不能很好表示特征间的关系。</p></li><li><p>分布式表示</p><p>向量维度低，方便扩展，相似度也可以计算</p></li></ol><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>嵌入：将一个度量空间中的一些对象映射到另一个低维的度量空间中，并尽可能保持不同对象之间的拓扑关系。（由高维空间映射到低维空间）</p><h4 id="深度学习-Deep-Learning"><a href="#深度学习-Deep-Learning" class="headerlink" title="深度学习(Deep Learning)"></a>深度学习(Deep Learning)</h4><p>“深度”：指原始数据进行非线性<strong>特征转换</strong>的次数</p><p>深度学习的目的是从数据中<strong>自动</strong>学习到有效的<strong>特征表示</strong>（之前都是人工设计特征偏多）</p><p>深度学习需要解决问题：<strong>贡献度分配</strong><br>即一个系统中不同的组间或其参数对最终系统输出结果的贡献或影响。</p><h5 id="端到端学习"><a href="#端到端学习" class="headerlink" title="端到端学习"></a>端到端学习</h5><p>端到端学习指在学习过程中，不进行分模块或分阶段训练，直接优化任务的总目标，端到端学习的中间过程不需要人为干预。训练数据为“输入-输出”对的形式而不需要提供其他信息。</p><p>深度学习算是一种端到端学习</p><h4 id="神经网络-Neural-Network"><a href="#神经网络-Neural-Network" class="headerlink" title="神经网络( Neural Network)"></a>神经网络( Neural Network)</h4><p>神经网络是指由很多人工神经元构成的网络结构模型，这些人工神经元之间的连接强度是可学习的参数。</p><p>详细内容还需要通过后面的学习认识。</p><p>发展历史：<br>模型提出 – 冰河期（反向传播算法提出被忽略）– 反向传播算法引起复兴（梯度消失问题出现）<br>– 流行度降低 – 深度学习的崛起（以神经网络为基础）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-04</title>
      <link href="/2020/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04/"/>
      <url>/2020/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04/</url>
      
        <content type="html"><![CDATA[<h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><p><strong>bilbil：P12、P14</strong></p><h4 id="三步走："><a href="#三步走：" class="headerlink" title="三步走："></a>三步走：</h4><p><img src="/2020/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04/01.png" alt="01"></p><ul><li>step1：确定网络的链接方式，确定网络结构一种连接方式可以对应一个function set</li></ul><a id="more"></a><h5 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h5><p><strong>链接方式介绍：</strong></p><ul><li>fully connect feedforward network<br>（全连接前馈网络）<br><img src="/2020/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04/02.png" alt="02"></li></ul><p>  特点：</p><ol><li><p>input传递是从低级的layer向高级的layer传递，所以是forward</p></li><li><p>对于低级layer的每一个神经元（neuron）得到的对应的output结果，要传给下一层的每一个neuron，这则是所谓的Fully，全连接。</p><p>Deep = many hidden layers（很多的隐藏层）</p><p>一个layer的运算可以通过一个矩阵表示。整个全连接网络可以用矩阵的计算表示，好处在于矩阵运算可以通过GPU加速。<br><img src="/2020/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04/02.png" alt="03"><br>里面的正方形是矩阵<br>长方形也是，但同时也是一个向量。</p><p><strong>hidden layers中，主要是将原始的feature进行一定的变换，使得在最后的output层可以比较容易的得到好的模型</strong></p></li></ol><p>Q:如何决定层数、决定每层的神经元数、决定链接方式？（好的结构里面存在好的function）</p><p>A:直觉、经验、尝试等</p><h5 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h5><p>定义function的好坏，利用training data，同逻辑回归的方式。利用梯度下降的方式，最小化Loss函数，得到相应的function和它的参数集。</p><h5 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h5><p>选择好的function</p><h4 id="WHY-DEEP"><a href="#WHY-DEEP" class="headerlink" title="WHY DEEP?"></a>WHY DEEP?</h4><p>问题：为什么是增加层数layer，而不是在中间层不断增加神经元？实质是在<strong>参数相同</strong>的情况下，层数更多的（thin）网络结构表现更好（deep），还是一层内神经元更多的（fat）网络结构表现更好？</p><p>结果表明，层数更多比单单一层更多神经元的结构表现效果好很多。<br>原因：deep是在模块化网络。模块化的好处是能够减少冗余、重复利用。对于deep learning 来讲， 效果则是<strong>可以用比较少的data也能到的好的模型</strong>。底层的layer相当于basic classifier，高层的模型建立都是基于底层。<strong>模块化是机器自动从data学习而来。（？）</strong></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h4 id="语音中的模块化运用"><a href="#语音中的模块化运用" class="headerlink" title="语音中的模块化运用"></a>语音中的模块化运用</h4><h5 id="语音辨识初步过程"><a href="#语音辨识初步过程" class="headerlink" title="语音辨识初步过程"></a>语音辨识初步过程</h5><p>1、取语音音频，每次截取一小段并将其归类为不同的state<br>2、每一个state要进行分类，分给不同的phoneme（发音单位）（这里就用到了分类）<br>3、其中因为phoneme与前后的发音有关系，又将相同的phoneme分成不同的tri类，然后每个tri类又分为三份，理论上每一份对应一个model。<br>问题来了，这样的话model太多了，数据量根本训练不出好的模型。</p><p>发现：不同的“每一份”可以共用相同的分布模型。 —- 模块化</p><p>其实phoneme之间客观上也是有关系的。</p><p>deep learning做法：</p><ul><li><p>input：acoustic feature</p></li><li><p>output：probability of each state</p><p><strong>所有的states共用同一个DNN</strong>（深度神经网络）</p><p>先研究发音方式（模块化），然后进行发音分类</p></li></ul><p>DNN的好处（模块化）</p><ul><li>使用参数更有效率</li></ul><p>普遍性定理是，一层layer就可以将各种参数转换成想要的维度的输出，一层网络就可以表示所有的function，但是这样矮胖的网络结构是没有效率的。深层网络是比较有效率的。</p><h4 id="逻辑电路类比"><a href="#逻辑电路类比" class="headerlink" title="逻辑电路类比"></a>逻辑电路类比</h4><p>1、两层逻辑电路可以表示任何的boolean function。<br>2、但没有人会这么做，因为没有效率，多层结构比较有效率，可以用比较少的逻辑门。</p><p><strong>更少的逻辑门象征更少的参数需要计算，即降低overfitting的概率</strong><br><strong>逻辑电路中的道理和和深度神经网络是一样的</strong><br><strong>最终的效果是，较少的data可以训练出类似的结果</strong></p><h2 id="END-TO-END-learning"><a href="#END-TO-END-learning" class="headerlink" title="END TO END learning"></a>END TO END learning</h2><p>只给机器input 与 output，让其自己进行学习训练。</p><p>理论上的想法：</p><p><img src="/2020/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04/04.png" alt="04"></p><p>其中的function不会经过人工加工，不通过人工的之前的研究、经验，直接丢给机器，让其自主进行数据分析，功能完善。后来通过谷歌的研究发现，机器的再自主学习做出的最终结果与人类干预差不多，不会比人类知识干预要好，分析发现机器所做的学习和人类通过认知进行的数据干预处理是类似的。</p><h2 id="Deep-learning的其他好处"><a href="#Deep-learning的其他好处" class="headerlink" title="Deep learning的其他好处"></a>Deep learning的其他好处</h2><ul><li>有很多复杂的task，可能有的输入很类似，但是输出的结果应当是不同的；有的输入很不一样，但是输出的结果应该是相同的。想要达到这种效果，就需要让数据经过很多层次的转换。deep learning就可以实现这样的事情。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-03</title>
      <link href="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/"/>
      <url>/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/</url>
      
        <content type="html"><![CDATA[<h2 id="Classification-分类"><a href="#Classification-分类" class="headerlink" title="Classification 分类"></a>Classification 分类</h2><p>1、理论方法：三步走</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/01.png" alt="01"></p><p>概率知识：贝叶斯公式（后验概率），高斯分布</p><p>伯努利分布 == 二项分布</p><p>高斯分布 == 正态分布</p><a id="more"></a><h4 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h4><p>假设一个机率模型</p><p>1、training data 估测一个gaussian distribution（高斯分布结果），通过高斯分布计算出新的x在范围内被选择出来的几率。</p><p>2、不同的高斯分布对应不同的likelihood（可能性），找到分布中，面对training data数据，标记概率（likelihood）是最大的，选择这样的分布，得到相应的参数。</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/02.png" alt="02"></p><p>穷举各种μ与ξ的值，然后通过图片方法计算，选择最大可能性的一组参数</p><p>3、每个class都要计算第二步，得到相应的（μ，ξ)。</p><p>4、分类计算，计算输入的x来自于不同的class的几率</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/03.png" alt="03"></p><p>5、效果不好的时候（比如二维空间分类分不出来），可以提高feature的维度，即增加输入向量的长度。（最后计算效果不好！！:triumph:）</p><h4 id="改良处理"><a href="#改良处理" class="headerlink" title="改良处理"></a>改良处理</h4><p>1、减少模型参数，参数越多越容易overfitting，让不同的class共用一个ξ，使得likelihood最大。</p><p>计算参数方式：μ的计算同上，ξ的计算不同，需要加权计算一下，likelihood函数也不同,如图下</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/04.png" alt="04"></p><p>相同的ξ，让boundary变成了直线，这也是linear model。</p><p>计算后得出准确率高了很多。</p><h4 id="阶段总结——概率模型做（二）分类"><a href="#阶段总结——概率模型做（二）分类" class="headerlink" title="阶段总结——概率模型做（二）分类"></a>阶段总结——概率模型做（二）分类</h4><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/05.png" alt="05"></p><h4 id="相关数学知识（扩展）"><a href="#相关数学知识（扩展）" class="headerlink" title="相关数学知识（扩展）"></a>相关数学知识（扩展）</h4><p>1、linear model的导出过程：</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/06.png" alt="06"></p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/07.png" alt="07"></p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/08.png" alt="08"></p><h3 id="logistic-Regression"><a href="#logistic-Regression" class="headerlink" title="logistic Regression"></a>logistic Regression</h3><p>回顾分类设定的模型：</p><p>这是一个逻辑回归函数</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/09.png" alt="09"></p><p>2、通过训练集，选择出最合适的w,b参数：定义function的好坏</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/10.png" alt="10"><br>L是发生训练集所展现分类的概率函数，假设每个元素属于某一类都是相互独立的，所以计算L的方式是将计算出的概率（f函数）相乘。让L最大值所对应的w,b的值，就是我们模型中需要找出的w,b的值。</p><p>++++++++++++++++++++</p><hr><p><em>下面是数学相关的L函数的化简整理</em></p><p>理解这几条：</p><ul><li><p>因为L是累乘的结果，为了方便计算，取ln变成累加，再整体取符号，化取最大值为取最小值。</p></li><li><p>引入y^，（二分类中）y取1表示输入class1，取0表示属于class2.</p></li><li><p>将每一项的形式都通过y^的引入而同一成相同形式</p></li><li><p>统一出来的相同形式是两个二项分布的交叉熵，其中交叉熵越接近0代表两个分布越相同，我们想要的就是交叉熵尽可能接近0.</p></li></ul><p>以下是ppt讲义部分：</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/11.png" alt="11"></p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/12.png" alt="12"></p><p>其中y的取值只有1与0，f因为是个概率函数取值在0-1之间，所以方括号内的部分一定是小于零的，加上外面的负号会大于0，所以方括号越趋近于零，一个是代表两个分布越接近，另一个也是代表-lnL的值趋向最小，表示模型越来越匹配，所以交叉熵越趋近于0越好。</p><p>下面的H是交叉熵的计算方法。</p><p>于是我们可以得到逻辑回归（二分类）的判定模型好坏的函数L。</p><hr><hr><h4 id="逻辑回归与线性回归的对比"><a href="#逻辑回归与线性回归的对比" class="headerlink" title="逻辑回归与线性回归的对比"></a><strong>逻辑回归与线性回归的对比</strong></h4><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/13-1.png" alt="13"></p><p>Q:为什么不能直接使用线性回归的L函数（square error）当作逻辑回归的L函数，线性的相对而言更简单易算？</p><p>A：利用梯度下降的方式逼近最合适的w的时候，会出现无法区别距离实际值到底很近还是很远的状况，在梯度下降的时候会卡住，不容易得到好的结果：</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/16.png" alt="16"></p><p>3、通过Loss函数计算最佳w，b的方法：<br>数学问题，对Loss函数对w求偏微分，通过一系列变换，得到一个直观的结果。然后通过梯度下降的方法，求得loss的最低点w的值<br><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/14.png" alt="14"></p><p><strong>总结对比</strong></p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/15.png" alt="15"></p><h4 id="生成模型和判别模型对比（有些不懂）"><a href="#生成模型和判别模型对比（有些不懂）" class="headerlink" title="生成模型和判别模型对比（有些不懂）"></a>生成模型和判别模型对比（有些不懂）</h4><p>（暂时理解）生成模型是最初的分类模型，计算ξ、μ参数的那个模型（假定过分布服从正态分布）</p><p>判别模型就是上面的概率模型，直接计算w，b参数的模型。</p><p>两个模型实质是相同的，（w,b),(μ，ξ)也都有一定对应关系，但是计算出的结果会发现参数的结果不同，也就是求出的具体模型是不同的。原因就在于生成模型提前有过很多假设，也对模型的计算产生一定的影响。</p><p>生成模型（generative model）的好处是：</p><ul><li>training data很少的时候，生成模型受data的影响小，有自己的假设，有时反而表现很好</li><li>data可能本来存在问题的时候，因为受data影响小，所以可能表现更好。</li></ul><p>判别模型的好处是：</p><ul><li>受data影响大，所以数据足够多足够准确的时候，计算出来的模型更优。</li></ul><h4 id="多分类问题（三分类为例）"><a href="#多分类问题（三分类为例）" class="headerlink" title="多分类问题（三分类为例）"></a>多分类问题（三分类为例）</h4><p>（笔记记得稍微有点简单，先大体理解一下）</p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/17.png" alt="17"></p><p><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/18.png" alt="18"></p><h4 id="逻辑回归的限制"><a href="#逻辑回归的限制" class="headerlink" title="逻辑回归的限制"></a>逻辑回归的限制</h4><p>因为回归依旧是一条直线，所以总会存在，根本无法通过一条直线将类别分离的情况。</p><p>解决方式：Feature Transformation<br>将特征值转化<br>eg:<br><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/19.png" alt="19"></p><p>问题：如果找到合适的transformation？</p><p>回答：交给机器</p><p>进行多层的logistic regression，直到类别可以完全分开。然后将处理好的新的特征值，再进行逻辑回归，得到好的模型结果。<br><img src="/2020/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/20.png" alt="20"></p><p><strong>每一个逻辑回归又叫做“神经元”（neuron），整个网络是神经网络（neural network）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine_learning_作业1</title>
      <link href="/2020/07/12/Machine-learning-%E4%BD%9C%E4%B8%9A1/"/>
      <url>/2020/07/12/Machine-learning-%E4%BD%9C%E4%B8%9A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-07胡言乱语</title>
      <link href="/2020/07/06/2020-07%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
      <url>/2020/07/06/2020-07%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>我也不知道写点什么，想到哪里写到那里吧</p><a id="more"></a><p>《关于追星？》</p><p>​         最近总在想，喜欢上次次子对自己而言，到底是怎么样的。我喜欢他们，因为他们正能量、努力、积极向上、虽然公司非常非常不给力但是他们都能一直坚持到现在，我喜欢他们追求梦想的坚定，喜欢他们之间如亲人一样的羁绊，喜欢他们有趣的性格，喜欢他们在一起始终天真如以往。我喜欢他们的理由，是我希望自己也能做到的地方。可是喜欢了他们，太多的时间花费在看他们的物料上，没有物料就反复看从前的物料，自己现实生活没有认真地度过，逃避的地方太多了，对太多东西都丧失了兴趣，我觉得反而与自己想要的背道而驰。喜欢他们真的很快乐，但是也要看到喜欢他们对自己日常生活的不好的影响。追星应该是日常生活的调味剂，或者像那个写论文的姐姐一样，只是休息时候的消遣，而不应该为了看物料，耽误了正经事情。这点我一定要意识到，我已经二十了，不应该这么不懂事了。</p><p>​         我知道现在让自己一下子断开很难，因为每次打开pad-&gt;打开b站-&gt;搜索seventeen，已经成为自己的一个习惯了，所以切断一切的源头，还是要戒手机、戒网络。所以，最近一阵儿手机先收起来，让自己心静下来，在慢慢地恢复正常的追星的感觉。记住自己的追星原则：</p><ul><li><strong>帅哥没有事业重要</strong></li><li><strong>白嫖的帅哥最美味</strong></li></ul><p><strong>希望追星给自己带来的，是正能量，是自己喜欢的那种美好的东西。而不是成为自己逃避现实的老鼠洞。</strong></p><p>《关于音乐》</p><p>音乐，是我觉得我真的很热爱的东西。如果热爱，<strong>就去行动吧</strong>，总是心痒痒的，很不好受吧。</p><p>好像难题解决了呢，感觉好容易呀哈哈哈，那就开始行动吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嗯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-02</title>
      <link href="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/"/>
      <url>/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/</url>
      
        <content type="html"><![CDATA[<h3 id="regression-回归"><a href="#regression-回归" class="headerlink" title="regression 回归"></a>regression 回归</h3><h5 id="linear-model-线性模型"><a href="#linear-model-线性模型" class="headerlink" title="linear model 线性模型"></a>linear model 线性模型</h5><p>1、设计模型</p><p>2、评价确定的参数是否合适，利用Loss function L，损失来评价</p><p>3、通过数据训练模型training data</p><p>4、testing data计算ERROR</p><p>挑选最好的function，也就是使得损失最小的function</p><a id="more"></a><p>计算方法：<strong>梯度下降Gradient Descent</strong>，寻找L（loss）的最低点</p><ul><li>随机选取初始点W0</li><li>计算W0对L的微分，切线斜率，判断w0的值如何变动（取决于微分与learning rate），w0-》w1</li><li>反复执行第二步</li><li>最后找出的是局部最优解，也就是微分为0的位置。不一定全局最优（linear上不存在这个问题。没有局部最优解）</li><li>关于推广：一个参数推广到两个参数的时候，也就是偏微分的计算，与一个变量原理相同。</li></ul><p>5、优化模型：再设计、再训练、再评价，模型由简单到复杂</p><p>model越来越复杂，training data 越来越匹配，但testing data表现不一定  ——》overfitting 过拟合，所以要选择合适的model</p><p>适当引入feature用于分类（？），可以使模型更匹配</p><p>Q:为什么我们更期待一个参数更接近0的function?</p><p>A:比较平滑的，参数小可以让输入对于输出的变化不敏感。（？）</p><p><img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/07" alt="image-20200705193554878"></p><p>1、bias的影响：看结果集合与中心的偏离程度 （模型的复杂程度影响，越复杂，bias越小）</p><p>样本均值和总体均值的关系（？）———无偏估计</p><p>样本均值的期望等于总体均值———bias小</p><p>2、variance的影响：看结果集的分散程度（模型的复杂程度会影响variance,越复杂，variance越大)</p><p>样本方差和总体方差的关系（？）———有偏估计</p><p><strong>简单model受到样本数据的影响比较小</strong></p><p><strong>确定一种model，相当于确定了一种范围，模型越复杂，范围越大，范围越大。点更容易分散</strong></p><p>两者越低越好，寻找平衡</p><p>variance大：overfitting（training拟合好，但是test拟合不好）————增加data/regularization正则化</p><p>bias大：underfitting（training拟合不好）————重新设计model</p><p>更复杂：更多的feature，更高的阶层</p><h5 id="Gradient-Descent-梯度下降"><a href="#Gradient-Descent-梯度下降" class="headerlink" title="Gradient Descent 梯度下降"></a>Gradient Descent 梯度下降</h5><ul><li><p>过程：</p><p><img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/01.jpg" alt="01"></p><p>其中<img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/02.jpg" alt="02"> 即为梯度，因为前面有了负号，所以点的移动总是向着梯度下降的方向进行，因而叫做梯度下降。</p></li><li><p>关于learning rate</p><p>太小：梯度下降处理速度慢</p><p>太大：直接错过min值</p><p>措施：关注前几次的参数updates，画图(如下图所示），可以提前发现太大的learning rate，当loss值可以稳定下降的时候，rate才相对合适</p><p><img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/03.jpg" alt="03"></p><p><strong>调整方法</strong>：可以将learning rate 成为t（次数）的函数。learning rate的变化规律一般为：值可以先很大，方便我们快速定位到最小值附近，然后值减小，慢慢靠近最低值，防止因为值过大错过最低值。</p><p><strong>注意！learning rate也是要随着不同的参数而变化的，不是一成不变的，而且对于同一时间段的多种参数（如w，b等），learning rate 依旧有差别</strong></p><h6 id="Adagrad："><a href="#Adagrad：" class="headerlink" title="Adagrad："></a>Adagrad：</h6><p><img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/04.jpg" alt="04"></p><p><strong>g是对应参数关于x的微分或偏微分，所以η是关于下降次数(t)的函数，σ是关于对应参数微分(g)的函数，由此得出的learning rate可以和t与g相关</strong></p><p><img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/05.jpg" alt="05"></p></li></ul><h6 id="Stochastic"><a href="#Stochastic" class="headerlink" title="Stochastic"></a>Stochastic</h6><p>只选择某一个example的Loss值，通过一个example进行梯度下降，得到相应参数。</p><ul><li>好处：速度快，同样的起始点，可以update参数的次数变多了，计算内容少，更快。</li></ul><h6 id="Feature-Scaling-特征缩放"><a href="#Feature-Scaling-特征缩放" class="headerlink" title="Feature Scaling   特征缩放"></a>Feature Scaling   特征缩放</h6><p>让不同的特征，有相同的比例，统一到一定的范围内。让每个参数对目标的影响程度相似。这样子learning rate也能够相对平稳一些。</p><ul><li><p>方法：</p><p><img src="/2020/06/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/06.jpg" alt="06"><br>mean：均值，standard deviation：标准差</p></li></ul><h6 id="Theory-理论基础"><a href="#Theory-理论基础" class="headerlink" title="Theory 理论基础"></a>Theory 理论基础</h6><p>泰勒级数，泰勒展开</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记-01</title>
      <link href="/2020/06/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
      <url>/2020/06/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Machine learning 三步骤</p><p>框架：</p><p><img src="/2020/06/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/01.png" alt="01"></p><a id="more"></a><h4 id="定义中英对照表"><a href="#定义中英对照表" class="headerlink" title="定义中英对照表"></a>定义中英对照表</h4><table><thead><tr><th align="center">English</th><th align="center">Chinese</th></tr></thead><tbody><tr><td align="center">Reinforcement learning</td><td align="center">强化学习</td></tr><tr><td align="center">Supervised learning</td><td align="center">监督学习</td></tr><tr><td align="center">Reinforcement learning</td><td align="center">无监督学习</td></tr><tr><td align="center">linear</td><td align="center">线性</td></tr><tr><td align="center">Network Architecture</td><td align="center">网络架构</td></tr><tr><td align="center">Gradient Descent</td><td align="center">梯度下降</td></tr><tr><td align="center">Adversarial Attack</td><td align="center">对抗攻击</td></tr><tr><td align="center">Explainable AI</td><td align="center"></td></tr><tr><td align="center">Network Compression</td><td align="center">网络压缩</td></tr><tr><td align="center">Anomaly Detection</td><td align="center"></td></tr><tr><td align="center">Transfer Learning</td><td align="center">迁移学习</td></tr><tr><td align="center">Meta learning</td><td align="center">元学习</td></tr><tr><td align="center">life-long learning</td><td align="center">终身学习</td></tr><tr><td align="center">Regression</td><td align="center">回归</td></tr><tr><td align="center">parameter</td><td align="center">参数</td></tr><tr><td align="center">feature</td><td align="center">特征</td></tr><tr><td align="center">optimal</td><td align="center">最优的</td></tr><tr><td align="center">convex</td><td align="center">凸函数</td></tr><tr><td align="center">overfitting</td><td align="center">过拟合</td></tr><tr><td align="center">generalization</td><td align="center">一般化</td></tr><tr><td align="center">regularization</td><td align="center">正则化、规范化</td></tr><tr><td align="center">bias</td><td align="center"></td></tr><tr><td align="center">variance</td><td align="center"></td></tr><tr><td align="center">estimator</td><td align="center">估计、预估</td></tr><tr><td align="center">validation set</td><td align="center">验证集（training data的一部分）</td></tr><tr><td align="center">cross validation</td><td align="center">交叉验证</td></tr><tr><td align="center">optimization</td><td align="center">最佳化、最优化</td></tr><tr><td align="center">root mean square</td><td align="center">均值平方根</td></tr><tr><td align="center">prior</td><td align="center"></td></tr><tr><td align="center">vector</td><td align="center">向量</td></tr><tr><td align="center">gaussian distribution</td><td align="center">高斯分布</td></tr><tr><td align="center">maximum likelihood</td><td align="center">最大似然</td></tr><tr><td align="center">naive bayes</td><td align="center">朴素贝叶斯</td></tr><tr><td align="center">sigmoid function</td><td align="center">S型函数</td></tr><tr><td align="center">logistic Regression</td><td align="center">逻辑回归</td></tr><tr><td align="center">cross entropy</td><td align="center">交叉熵</td></tr><tr><td align="center">Bernoulli Distribution</td><td align="center">伯努利分布、二项分布</td></tr><tr><td align="center">generative model</td><td align="center">生成模型</td></tr><tr><td align="center">Discriminative Model</td><td align="center">判别模型</td></tr><tr><td align="center">Neuron</td><td align="center">神经元</td></tr><tr><td align="center">neural network</td><td align="center">神经网络</td></tr><tr><td align="center">modularization</td><td align="center">模块化</td></tr><tr><td align="center">speech recognition</td><td align="center">语音辨识</td></tr><tr><td align="center">Backpropagation</td><td align="center">反向传播</td></tr><tr><td align="center">chain rule</td><td align="center">链式法则</td></tr><tr><td align="center">recursice</td><td align="center">递归的、循环的</td></tr><tr><td align="center">convolutional neural network</td><td align="center">CNN,卷积神经网络</td></tr><tr><td align="center">subsampling</td><td align="center">二次抽样</td></tr><tr><td align="center">filter</td><td align="center">过滤器</td></tr><tr><td align="center">Feature map</td><td align="center">特征图谱</td></tr><tr><td align="center">feedforward</td><td align="center">前馈</td></tr><tr><td align="center">dimension</td><td align="center">方面，维数</td></tr><tr><td align="center">initial</td><td align="center">最初的</td></tr><tr><td align="center">gradient vanishing</td><td align="center">梯度消失</td></tr><tr><td align="center">gradient explode</td><td align="center">梯度爆炸</td></tr><tr><td align="center">neural turing machine</td><td align="center">图灵机</td></tr><tr><td align="center">Semi-supervised learning</td><td align="center">半监督学习</td></tr><tr><td align="center">Support Vector Machine（SVM）</td><td align="center">支持向量机</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习日志</title>
      <link href="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>python学习中遇到的知识总结一下</p><p>2020-04-25更新</p><a id="more"></a><p>1、安装工具包</p><p>命令：<strong>python -m pip install packagename</strong></p><p> <strong>python -m pip install -U pip setuptools</strong> 更新pip和setuptools包</p><p>2、python交互式帮助系统<strong>help（）</strong></p><p>（1）查看模块</p><ul><li><strong>modules</strong>  查看计算机中所有模块</li><li><strong>module name</strong>  输入模块名可以查看详细内容</li><li><strong>module name. function name</strong>  句号表示法查看函数内容</li><li><strong>modules module name</strong>  查看与该模块相关的模块</li></ul><p>（2）</p><ul><li>dir(<strong>builtins</strong>)#两个下划线  查看内置函数列表</li><li>class  输入内置类名可以查看内置类</li></ul><p>n、冷知识</p><p>（1） REPL：在控制台上交互执行python代码的过程（所以在sublime上配置的可以交互运行python的叫REPL啊。。</p><p>04-20新奇知识</p><p>1、动态函数</p><p>（1）eval：动态表达式的求值</p><p><img src="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/01-1.png" alt="01"></p><p><img src="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/01-2.png" alt="02"></p><p>（2）exec函数：动态语句执行</p><p><img src="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/01-3.png" alt="03"></p><p><img src="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/01-4.png" alt="x"></p><p>（3）compile函数：动态语句执行</p><p><img src="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/01-5.png" alt="05"></p><p><img src="/2020/04/25/python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/01-6.png" alt="06"></p><p>2、函数式编程</p><p>（0）高阶函数：<strong>参数为函数对象的函数或返回函数对象的函数，称之为高阶函数，即函数的函数</strong></p><p>f函数作为另一个函数的对象，是另一个函数的参数。</p><p>（1）map函数，返回可迭代对象</p><p>map(f,iterable,……)将f作用与可迭代对象中的每一个值，依次作用，并返回可迭代对象，f是函数。</p><p>（2）filter函数 过滤器</p><p>filter（f,iterable,……）返回可迭代对象，会根据f的作用，保留可迭代对象中f作用返回为true的值，返回可迭代对象。</p><p>（3）lamda表达式和匿名函数</p><p>在一行里定义一个函数，生成函数对象，即匿名函数</p><p>格式：lamda x1,x2，……：f(x1,x2,……)</p><p>x1,x2是参数，f是对参数的做法</p><p>（4）sorted()函数：对可迭代对象进行排序</p><p>参数：key：排序法则，调用函数，导入函数对象</p><p>reverse：升序（False)降序(True)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;游走记忆的时间__中文填词</title>
      <link href="/2020/04/25/%E8%BD%AC-%E6%B8%B8%E8%B5%B0%E8%AE%B0%E5%BF%86%E7%9A%84%E6%97%B6%E9%97%B4-%E4%B8%AD%E6%96%87%E5%A1%AB%E8%AF%8D/"/>
      <url>/2020/04/25/%E8%BD%AC-%E6%B8%B8%E8%B5%B0%E8%AE%B0%E5%BF%86%E7%9A%84%E6%97%B6%E9%97%B4-%E4%B8%AD%E6%96%87%E5%A1%AB%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>《游走记忆的时间》是我很喜欢的一首歌，在不懂得韩语歌词的情况下便被吸引。初听旋律会觉得很温柔很治愈，了解了歌词的含义后又会觉得有些悲伤。想尝试自己填一下中文歌词，现在文学素养和音乐乐理都有很大的不足，不过没关系，慢慢来，人还是要有梦想的。</p><p>这里有一个填的很不错的歌词，收藏下来学习一下。。</p><a id="more"></a><p>中文填词 by 有趣的AC<br>PV图片from：泰妍IG</p><p>转自b站</p><p><a href="https://www.bilibili.com/video/BV1Ws411p7Rb?from=search&amp;seid=22808107266942372" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ws411p7Rb?from=search&amp;seid=22808107266942372</a></p><p>还能够，听你的歌低着头<br>还能够，假装握着你的手<br>还不够，好想淹没在你褐色的眼眸</p><p>还能够，看着你对镜头说<br>还能够，闻着你旧的枕头<br>还不够，仿佛时间溜走像一个小偷</p><p>当我失去力气又漫无目的地在人海游走<br>当我习惯压抑又刻意逃避只愿随波逐流<br>当我嗅着晚风正刮过树叶那干燥的气息<br>好像我的梦境它从未醒来，我还是拥有你</p><p>好想，回到很久以前，回到很久以前<br>我知道你也会愿意<br>回到很久以前</p><p>还能够，默出你的座右铭<br>还能够，明明咫尺却隐忍舞台之后<br>No，这样不够</p><p>每天都，看见你新的笑容<br>每天都，听到你有多优秀，<br>I know，我始终不能够原谅的优秀</p><p>当我失去力气又漫无目的地在人海游走<br>当我习惯压抑又刻意逃避只愿随波逐流<br>当我嗅着晚风正刮过树叶那干燥的气息<br>好像我的梦境它从未醒来，我还是拥有你</p><p>好想，回到很久以前，回到很久以前<br>但你的眼神告诉我<br>唯恐避之不及</p><p>当你偶尔休息又重访故地在街边的长椅<br>当**惯口渴却不常备着你爱喝的可乐<br>当你无意之间走进了街边我在的便利店<br>好像我的梦境它突然醒来，我从未拥有你</p><p>突然，唯恐避之不及，唯恐避之不及<br>当你的眼神告诉我<br>唯恐避之不及<br>是你</p><p>啦啦啦<br>唯恐避之不及<br>啦啦啦<br>唯恐避之不及</p><p>打开记忆被尘封的门锁，你的温柔疯狂地倒放着<br>酸涩海水倒灌进我眼中<br>打开记忆被尘封的门锁，你的渴望疯狂地倒放着<br>酸涩海水倒灌进我眼中<br>打开记忆被尘封的门锁，你的坚决疯狂地倒放着<br>酸涩海水倒灌进我眼中<br>打开记忆被尘封的门锁，你的一切疯狂地倒放着<br>此刻的我已渐渐没有痛</p><p>啦啦啦<br>已渐渐没有痛<br>啦啦啦<br>怎么会没有痛</p>]]></content>
      
      
      
        <tags>
            
            <tag> 填词向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫遇到的问题一览</title>
      <link href="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/"/>
      <url>/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h6 id="正在进行有关爬虫的课程项目，在这里把爬虫过程中遇到的问题、报错、感想等都总结一下"><a href="#正在进行有关爬虫的课程项目，在这里把爬虫过程中遇到的问题、报错、感想等都总结一下" class="headerlink" title="正在进行有关爬虫的课程项目，在这里把爬虫过程中遇到的问题、报错、感想等都总结一下"></a>正在进行有关爬虫的课程项目，在这里把爬虫过程中遇到的问题、报错、感想等都总结一下</h6><a id="more"></a><p>2020年4月15日</p><p>今天想要实现的功能是爬取网易云用户主页的收藏歌单，歌单的具体内容（标签、介绍）</p><p>今天处理的问题有：<br>（1）链接跳转以及页面过期问题<br>（2）定位节点以及模拟节点点击问题<br>（3）节点不存在的错误抛出问题</p><p>1、链接跳转即页面过期问题：</p><p>想要爬取歌单的更多信息，需要跳转到歌单所在的页面，经过的网页源码的分析可以发现，每个表示歌单节点的内容里可以找到关于该歌单的网页地址，通过browser的get再定位就可以跳转到相应的页面。</p><p>关于歌单节点的网页分析如下图所示：</p><p><img src="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/pic01.png" alt="pic01"></p><p><img src="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/pic02.png" alt="pic02"></p><p>直接利用在用户主页获取的收藏歌单节点的列表lists进行元素遍历，然后依次访问每个歌单的链接，会发现报错: <em>StaleElementReferenceExcepti</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium.common.exceptions.StaleElementReferenceException: Message: stale eleme</span><br></pre></td></tr></table></figure><p>这个错误表示页面内容的过时，即已经跳转到新的页面了，但是lists连接原本的是旧页面，现在获取的都是新页面里面的li的内容，自然找不到想要的内容（自己理解的原理，不一定正确），因而过时错误。</p><p><strong>解决方法</strong>：在转换页面前，将lists中想要的li节点的属性href重新保存在一个新的列表里，然后遍历新的列表即可。</p><p>相关代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''lists是之前函数获取的li节点的合集列表'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_moreinfo</span><span class="params">(lists)</span>:</span><span class="comment">#获取与歌单信息相关的内容</span></span><br><span class="line">id0 =<span class="string">'g_iframe'</span></span><br><span class="line">news = []<span class="comment">#新的用于保存href的列表</span></span><br><span class="line"><span class="comment">#for li in lists:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):<span class="comment">#需要另保存在一个列表里，因为会存在过时问题</span></span><br><span class="line"><span class="comment">#newurl = str(li.get_attribute('href'))#这是歌单的网址</span></span><br><span class="line">newurl = str(lists[i].get_attribute(<span class="string">'href'</span>))<span class="comment">#这是歌单的网址</span></span><br><span class="line">news.append(newurl)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">browser.get(news[i])</span><br><span class="line">browser.switch_to.frame(id0)</span><br></pre></td></tr></table></figure><p>2、定位节点以及节点点击问题<br><strong>问题引入</strong>：歌单详细信息的介绍内容经常需要鼠标点击“展开”按钮后，里面所有的内容才能完全的显示出来被爬虫获取，因而需要获取“展开”节点并模拟点击该节点。<br>网页结构如图所示：<br><img src="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/pic03.png" alt="pic03"></p><p>定位节点即通过find相关函数，输入节点特有属性值，即可找到节点，目前更常用的是ccs选择器，觉得一目了然，比较简单。<br>节点点击：简单版：获取的节点（WebElement类型）.click（）<br>（更难的还在探索过程中……）<br>出现的问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebDriverException: Message: Element is not clickable at point (918, 13). Other element would receive the click: &lt;div class="xxx"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个错误目前了解的不是很多，大体的意思是点击这个button的时候，这个单击事件被上层的div给接收了……说明div覆盖在这个button上面。上面的div可能也存在相应的节点，导致点击事件被截获。</p><p><strong>解决方法</strong> ：我是再去找节点的特殊性，使节点只能定位到我想操作的那一个节点上，该节点的文本内容只有“展开”，而其他节点可能是“展开XXX”，借助str中的方法endswith(),判断点的后缀是否是“展开”来定位到该节点并click（）打开</p><p>相关代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''判断是否有需要展开的内容'''</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">check = browser.find_element_by_css_selector(<span class="string">'#album-desc-spread'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> check.text.endswith(<span class="string">'展开'</span>):</span><br><span class="line">check.click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>3、节点不存在的错误抛出问题</p><p><strong>问题引入</strong>:不同的歌单有不同的属性。有的歌单可能标签+介绍+介绍展开三者节点都存在，有的可能只存在一个或两个，有的甚至一个节点都不存在。如图所示：<br><img src="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/pic04.png" alt="pic04"><br>                                                                                  三种节点都有的歌单</p><p><img src="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/pic05.png" alt="pic05"><br>                                                                                  有两种节点的歌单</p><p><img src="/2020/04/15/python%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%E8%A7%88/pic06.png" alt="pic06"><br>                                                                                一个节点都没有的歌单</p><p>如果获取不存在的节点会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element:</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置异常抛出，没找到节点不执行任何行为，找到了则输出相关内容，三个节点都要判断。<br>相关代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''输出介绍信息'''</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">des = browser.find_element_by_css_selector(<span class="string">'#album-desc-more'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(des.text)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一开始会出现<em>NameError: name ‘NoSuchElementException’ is not defined</em>的报错，即python内部没有相关错误类，通过引入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法一览</title>
      <link href="/2020/02/23/markdown%E8%AF%AD%E6%B3%95%E4%B8%80%E8%A7%88/"/>
      <url>/2020/02/23/markdown%E8%AF%AD%E6%B3%95%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h6 id="总结自己新get的以及总是记不住的markdown语法"><a href="#总结自己新get的以及总是记不住的markdown语法" class="headerlink" title="总结自己新get的以及总是记不住的markdown语法"></a>总结自己新get的以及总是记不住的markdown语法</h6><a id="more"></a><p>1、添加链接</p><ul><li><p>给文字添加链接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接文字]（链接网址 <span class="string">"标题"</span>）</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [June<span class="string">'s blog](https://junewang0614.github.io/ "June")</span></span><br></pre></td></tr></table></figure><p>This is <a href="https://junewang0614.github.io/" title="June">June’s blog</a></p></li><li><p>插入图片链接</p><ul><li>网络连接</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![name](网络链接)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![凯哥](https:<span class="comment">//c-ssl.duitang.com/uploads/item/201912/08/20191208152338_gasau.jpg)</span></span><br></pre></td></tr></table></figure><p><img src="https://c-ssl.duitang.com/uploads/item/201912/08/20191208152338_gasau.jpg" alt="凯哥"></p><ul><li><p>本地连接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![name](本地路径)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>2、创建表格</p><ul><li>简单</li></ul>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name <span class="params">| fun1 |</span>  fun2  </span><br><span class="line">-<span class="params">|-|</span>-</span><br><span class="line">aa <span class="params">| bb |</span> cc <span class="params">|</span></span><br><span class="line"><span class="params">ff |</span> ee <span class="params">| dd |</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>fun1</th><th>fun2</th></tr></thead><tbody><tr><td>aa</td><td>bb</td><td>cc</td></tr><tr><td>ff</td><td>ee</td><td>dd</td></tr></tbody></table><ul><li><p>中等</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name | <span class="number">111</span> | <span class="number">222</span> | <span class="number">333</span> | <span class="number">444</span></span><br><span class="line">- | :-: | :-: | :-: | -:</span><br><span class="line">aaa | bbb | ccc | ddd | eee| </span><br><span class="line">fff | ggg| hhh | iii | <span class="number">000</span>|</span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th align="center">111</th><th align="center">222</th><th align="center">333</th><th align="right">444</th></tr></thead><tbody><tr><td>aaa</td><td align="center">bbb</td><td align="center">ccc</td><td align="center">ddd</td><td align="right">eee</td></tr><tr><td>fff</td><td align="center">ggg</td><td align="center">hhh</td><td align="center">iii</td><td align="right">000</td></tr></tbody></table><p>可以居中</p></li><li><p>复杂</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name | <span class="number">111</span> | <span class="number">222</span> | <span class="number">333</span> | <span class="number">444</span></span><br><span class="line">:-: | :-: | :-: | :-: | :-:</span><br><span class="line">aaa | bbb | ccc | ddd | eee| </span><br><span class="line">fff | ggg| hhh | iii | <span class="number">000</span>|</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">name</th><th align="center">111</th><th align="center">222</th><th align="center">333</th><th align="center">444</th></tr></thead><tbody><tr><td align="center">aaa</td><td align="center">bbb</td><td align="center">ccc</td><td align="center">ddd</td><td align="center">eee</td></tr><tr><td align="center">fff</td><td align="center">ggg</td><td align="center">hhh</td><td align="center">iii</td><td align="center">000</td></tr></tbody></table></li><li><p>总结</p><p><strong>-:表示内容和标题栏居右对齐</strong></p><p><strong>:-表示内容和标题栏居左对齐</strong></p><p><strong>:-:表示内容和标题栏居中对齐</strong></p><p><strong>内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略</strong></p><p><strong>-的数量至少有一个。</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp刷题列表</title>
      <link href="/2020/02/23/dp%E5%88%B7%E9%A2%98%E5%88%97%E8%A1%A8/"/>
      <url>/2020/02/23/dp%E5%88%B7%E9%A2%98%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h6 id="将做过的感觉不错的动态规划的题目在这里整理一下"><a href="#将做过的感觉不错的动态规划的题目在这里整理一下" class="headerlink" title="将做过的感觉不错的动态规划的题目在这里整理一下"></a>将做过的感觉不错的动态规划的题目在这里整理一下</h6><a id="more"></a><ul><li><p>基础dp</p><table><thead><tr><th align="left">题目</th><th>名称</th></tr></thead><tbody><tr><td align="left">HDU2018</td><td><a href="https://vjudge.net/problem/HDU-2018" target="_blank" rel="noopener">母牛的故事</a></td></tr></tbody></table></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些软件安装遇到的问题</title>
      <link href="/2020/02/17/%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/17/%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h5 id="总结一下安装软件的问题以及如何使用一些软件"><a href="#总结一下安装软件的问题以及如何使用一些软件" class="headerlink" title="总结一下安装软件的问题以及如何使用一些软件"></a>总结一下安装软件的问题以及如何使用一些软件</h5><a id="more"></a><p>1、Anaconda：</p><ul><li><strong>Prompt</strong>  是设置了Anaconda 路径环境变量的命令提示行。</li><li><strong>conda</strong>  包管理器，各种命令可以创建、查看环境及其安装包的列表</li><li><strong>IPython</strong>  交互式解释器</li><li><strong>Spyder</strong>  IDE</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装问题总结</title>
      <link href="/2020/02/16/MySQL%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/16/MySQL%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="总结一下在安装MySQL时遇到的一些问题"><a href="#总结一下在安装MySQL时遇到的一些问题" class="headerlink" title="总结一下在安装MySQL时遇到的一些问题"></a>总结一下在安装MySQL时遇到的一些问题</h5><a id="more"></a><ol><li><p>配置环境变量。</p><p>用cmd运行mysql发现没有该指令，是因为没有配置相应环境变量，新建了系统变量MYSQL_HOME其中保存了mysql安装路径（直达bin目录），然后在path变量中同样添加了sql的bin目录路径。其实环境变量挺好配置，一般我失败的原因是因为在配置过程中有很多弹窗都需要点击<strong>确认</strong>,如果有遗漏就容易配置失败。</p></li></ol><ol start="2"><li><p>有关my.ini文件</p><p>在查询各种问题的时候，发现自己的安装目录下没有my.ini文件，一度怀疑自己没安上。。后来一篇博客上提示my.ini文件保存在<strong>ProgramData</strong>文件夹中，然后复制回了安装目录<strong>（Program Files\MySQL\MySQL Server x.y）</strong>…..这波操作是有点骚。。</p><p>my.ini是mysql的配置文件。</p></li></ol><ol start="3"><li><p>再次在cmd中运行mysql命令</p><p>再次运行的时候出现的错误问题是</p><blockquote><p> <strong>ERROR 1045 (28000): Access denied for user ‘ODBC’@’localhost’ (using password: NO)</strong></p></blockquote><p>好像就是没有进行密码登录，调用指令<strong>mysql -u root -p</strong><br>会提示密码输入，输入后即<strong>Welcome to the MySQL monitor.</strong></p></li></ol><ol start="4"><li><p>mysql的两个 配置参数</p><p>basedir 参数：指定了mysql的生成路径，即输入“mysqld install”生成文件<br>datadir 参数：指定了数据库文件的存放路径（也就是今天改了一上午的玩意儿……）</p></li></ol><ol start="5"><li><p>更改数据库文件的存放路径：就是更改datadir参数，注意因为管理员权限，文件不能随便更改，需要在别的地方更改后复制粘贴到相应文件夹中。更改过程需要将mysql服务器关闭。</p></li><li><p>更改数据库文件存放路径后更重要的是，当前目录下数据库的初始化（实测这种做法相当于恢复出厂设置，之前的数据库操作是没有初始化的，所以慎用，还需继续学习）</p></li></ol><ol start="7"><li><p>更改数据库文件存放路径基本过程（win10管理员模式下）：   </p><ul><li><p>关闭数据库服务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure></li><li><p>更改my.ini文件中datadir的配置</p></li><li><p>移除原mysql服务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -remove mysql</span><br></pre></td></tr></table></figure></li><li><p>初始化data文件，程序会自动创建</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --initialize-insecure</span><br></pre></td></tr></table></figure><p>会出现一种报错</p><blockquote><p>Failed to find valid data direatory.</p></blockquote><p>出现这种错误的情况有很多，可能是文件夹路径没有写准确等等。对于我来说，我出现的问题是需要设置user，即</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure><p>–user的作用是使用哪个用户来运行mysql server，好像其他的用户没有一定的访问权限。</p><p><strong>注意</strong> ：</p><p>–initialize 表示的是初始化，会更改原root的密码</p><p>-insecure 表示的是初始化后密码为空，若没有，则会随机生成密码，此时需要及时找到随机生成的密码。</p></li><li><p>在路径下出现Data文件夹则初始化成功</p></li><li><p>生成mysql服务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --install</span><br></pre></td></tr></table></figure></li><li><p>启动mysql服务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="8"><li><p>修改用户登录密码</p><p>实质是操作mysql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql</span><br><span class="line">ALTER USER &#39;name&#39;@&#39;localhost&#39; IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY &#39;new password&#39;;</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li>–console 可以显示运行情况，会在cmd中显示错误内容，而不需自己再去打开相应错误文件。u1s1，一定要学会看错误文件呀，虽然网上有教程，但毕竟需要具体问题具体解决。</li></ol><ol start="10"><li><p>一直以为mysql只能通过命令行来运行，后来查了一下可以用navicat，有图形化的界面可以管理数据库。navicat是需要注册激活，目前最新版15没有找到激活方法，所以用的是12，以下是教程链接：</p><p><a href="https://blog.csdn.net/niejiangshuai/article/details/87874999" target="_blank" rel="noopener">https://blog.csdn.net/niejiangshuai/article/details/87874999</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习计划-01-22修改</title>
      <link href="/2020/01/22/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-01-22%E4%BF%AE%E6%94%B9/"/>
      <url>/2020/01/22/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-01-22%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="学习计划（20-01-22修改）"><a href="#学习计划（20-01-22修改）" class="headerlink" title="学习计划（20-01-22修改）"></a>学习计划（20-01-22修改）</h3><p>  回到家里已经好几天了，是时候安排假期的学习了</p><a id="more"></a><ul><li><p>首先是关于数据结构与算法，在经过<del>不断挑选</del>深思熟虑之后最终决定先以《数据结构与算法c语言实现》复习数据结构，以《算法基础》来学习算法。</p><p>数据结构是上学期的学习内容，但个人感觉掌握的并不扎实，理解的也不到位，重点是自己上学期的代码量实在太少。假期决定整体复习一下数据结构，重点在于各类数据结构的代码实现，其实本想使用c++语言版，但感觉对个人而言还是有一定难度。如果有时间，希望能使用c++实现每种数据结构。</p><p>算法在暑假集训有了初步的认识感知，但没有系统学习过，其实想学习的算法的一大目的是因为三月份的蓝桥杯比赛，希望自己能拿到一个好成绩，目前选择《算法基础》入门，回校打算学习《算法》第四版。</p><p>下面说一下安排叭：</p><ol><li>最多一周，回顾基础的数据结构，包括线性数据结构、树形数据结构、还有其他的一些数据结构，基础操作代码实现。配套辅以洛谷的专题练习，以及leetcode中的相应题目。STL也要学喽。（截至01-31）</li><li>《算法基础》，复习数据结构的时候每天阅读一章，一周结束后回来刷题，定量一下每种思想至少7题吧。</li></ol></li><li><p>然后是编程语言学习，要学的有python和c#</p><ol><li>Python就是把《py从入门到实践》看完写完</li><li>c#目前有电子版《head first c#》看完写完</li></ol></li><li><p>然后是编程练习</p><ol><li>蓝桥杯每天10个题（暂定），难的话每天5个题，3h，晚上写感想</li><li>洛谷按照板块刷题</li></ol></li></ul><hr><p><em>先这样吧</em><br><em>2020-01-22 修改</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-1-17</title>
      <link href="/2020/01/17/2020-1-17/"/>
      <url>/2020/01/17/2020-1-17/</url>
      
        <content type="html"><![CDATA[<h3 id="2020-1-17小记"><a href="#2020-1-17小记" class="headerlink" title="2020-1-17小记"></a>2020-1-17小记</h3><p>  腊月二十三， 北方小年，终于踏上回家的征程。在火车上读诗，读一会儿睡一会儿，醒了继续读，好不惬意。从前觉得很长的七个多小时竟也就这样慢慢打发过去了。可能是因为早车吧，难得的周围的座位人很少，旁边的座位从第二站过后倒是再也没有人坐过。几个同省的人上车，方言有一定的熟悉感，向北走的路程中，时不时能看到窗外的雪景，车里暖洋洋的，就这样也就回了家。</p><a id="more"></a><p>  小半年了吧，七月底就回了学校，除了自己的房间，自己在家里的痕迹也越来越少。果然啊，没有什么是能留住的，我们能抓住的，其实只有现在。这么简单的道理，竟也是最近才变得清晰起来。和同学讨论存储问题，他问，手机照片那么多，为什么不直接导进硬盘里，我说，还没有云备份。因为从前家里电脑硬盘损坏，也带走了数码相机的记忆。从此备两份，本地电脑与百度网盘。可是当我发出文字我才想到，云盘，也不过是一堆数据罢了，哪一天百度想要关闭网盘了，也不过是留不住罢了。这样看来，云盘仿佛比本地更为脆弱，本地的好歹掌握在自己手中，云上的，早被控制在他人手里罢了。</p><p>  我真的是一个很容易纠结的人，占有欲强，总想要留住那些想要留住的东西，紧紧握住，后来随着时间的流逝，也被慢慢遗忘在记忆的角落。这个过程自己也想不明白，不过是未来某天的日子里，看到什么熟悉的东西，或是听到什么熟悉的旋律，开启某段尘封已久的记忆，蓦然回首，发现已经走了好远好远。</p><p>  <strong>人生最深沉的悲剧不在于蓦然发生，而在于蓦然回首</strong></p><p>  早上从书里看到的这一句话。这篇故事讲述的是桂冠诗人弗罗斯特，讲述的主题是选择。选择，一个始终困扰我的词语。我畏惧选择，甚至不愿面对任何选择。从小了说，我厌烦购物时的货比三家，只是毕竟还是普通阶级，能省下的还是要省；能交给他人的选择，更愿意把权利让给对方。往大了说，那些只能由自己做出的选择，总是不到最后一刻不能下定决心，最后一刻的决心也是摇摇晃晃，只要有人稍加劝导，马上能够放弃的那种。为什么这么惧怕选择呢？一则是因为没有真正符合自己心意的选择吧，一方面是因为自己的野心配不上自己的能力，面对的选择也都不是自己想要的，另一方面，不过是自己的贪婪罢了，总觉得最好的选择是自己没有选择的，什么都想要，什么都失掉。</p><p>  <strong>选择的同义词从来都是放弃</strong></p><p>  选择总会意味着放弃另一或者多方面的选择，因为不甘放弃，所以畏惧选择。<br>  可我们总要在选择中成长，条条大路通罗马，想要去的远方，曲折一点又有何妨。<br>  只是没有什么是留得住的，留不住的就放手吧。抓住只能抓住的现在吧<br>  <em>present is a present</em></p><p>  这里是圆。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嗯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗的时光书</title>
      <link href="/2020/01/17/%E8%AF%97%E7%9A%84%E6%97%B6%E5%85%89%E4%B9%A6/"/>
      <url>/2020/01/17/%E8%AF%97%E7%9A%84%E6%97%B6%E5%85%89%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>在火车上阅读借了好久的《诗的时光书》，很多诗句挺喜欢的。</p><p>摘抄在下面。</p><p>伟大的文学尽管会道出悲剧的深刻，但也不会忘记昭示梦想的可贵。</p><a id="more"></a><blockquote><p><strong>凤凰</strong><br>    ——艾吕雅<br><em>我是你路上最后一个过客<br>最后一个春天，最后一场雪<br>最后一次求生的战争</em></p><p><em>我们永远背向西方<br>   一切都披上了曙光的色彩</em></p></blockquote><blockquote><p><strong>鲁拜集  第二十九首</strong><br>Into the universe, and why not knowing<br>Nor Whence, like Water willy nilly flowing<br>And out of it, as Wind along the Waste<br>I know not Whither, willy nilly blowing</p><p><em>我像流水不由自主地来到宇宙<br>不知何来，也不知何由<br>像荒漠之风不由自主地飘去<br>不知何往，也不能停留</em></p></blockquote><p>[未完待续]</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在开头</title>
      <link href="/2020/01/16/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/"/>
      <url>/2020/01/16/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="ABOUT-ME"><a href="#ABOUT-ME" class="headerlink" title="ABOUT ME"></a>ABOUT ME</h3><p>June，六月，也是我的英文名。这是自己搭建的第一个博客，很久没有在本地写markdown文件了，忘记了很多语法，写出来效果是什么也不敢保证。感觉有了博客就像有了自己的一个“云”家一样，什么都可以说，随心所欲。现在的小家只是有一个雏形，很多配置都还没有，慢慢地一点点填满，成为想要的样子。</p><a id="more"></a><hr><p>本来是想借助CSDN的博客，没事写写做题题解，写写学习感悟，写写实验流程，这个博客也是主要以学习为主吧，毕竟自己还是差的太远了，感觉不知不觉又荒废了一年时间，不过慢慢地很多东西倒是明了了起来，只是时间成本有点高，所以未来必须加倍努力。</p><hr><p>应该还会再写点自己的一些奇怪的ideas和feelings吧</p><p>反正，我的地盘我做主哈哈哈哈</p><p>这里是圆。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嗯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/16/hello-world/"/>
      <url>/2020/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
